{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let CONTRACT_NAME = "calculator.ride"
let SCALE8 = 100_000_000
let PENDING = "PENDING"
let FINISHED = "FINISHED"

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func keyFactoryAddress() = ["%s", "factory"].makeString(SEP)
func keyLpAssetId() = ["%s", "lpAssetId"].makeString(SEP)
func keyTreasuryAddress() = ["%s", "treasury"].makeString(SEP)
func keyAvailable(userAddress: Address) = ["%s%s", "available", userAddress.toString()].makeString(SEP)
func keyClaimed(userAddress: Address) = ["%s%s", "claimed", userAddress.toString()].makeString(SEP)
func keyCurrentPeriod() = ["%s", "currentPeriod"].makeString(SEP)
func keyPriceForPeriod(period: Int) = ["%s%d", "price", period.toString()].makeString(SEP)
func keyStartHeight(period: Int) = ["%s%d", "startHeight", period.toString()].makeString(SEP)
func keyPeriodLength() = "%s__periodLength"
func keyBlockProcessingReward() = "%s__blockProcessingReward"
func keyNextBlockToProcess() = "%s__nextBlockToProcess"
func keyBlockProcessed(height: Int) = ["%s%d", "blockProcessed", height.toString()].makeString(SEP)
func keyWithdrawalRequest(userAddress: Address, txId: ByteVector) =
  ["%s%s%s", "withdrawal", userAddress.toString(), txId.toBase58String()].makeString(SEP)
func valueWithdrawalRequest(status: String, lpAssetAmount: Int, targetPeriod: Int, claimTxId: ByteVector|Unit) = {
  let claimTxIdStr = match claimTxId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => "SOON"
  }
  ["%s%d%d%s", status, lpAssetAmount.toString(), targetPeriod.toString(), claimTxIdStr].makeString(SEP)
}
func parseWithdrawalRequestValueOrFail(s: String) = {
  let parts = s.split(SEP)
  if (parts.size() == 5) then {
    let status = parts[1]
    let lpAssetAmount = parts[2].parseInt().valueOrErrorMessage(wrapErr("invalid lpAssetAmount"))
    let targetPeriod = parts[3].parseInt().valueOrErrorMessage(wrapErr("invalid targetPeriod"))
    let claimTxId = parts[4]
    (status, lpAssetAmount, targetPeriod, claimTxId)
  } else {
    throwErr("invalid withdrawal request value")
  }
}

let factoryAddressOption = match this.getString(keyFactoryAddress()) {
  case s: String => s.addressFromString()
  case _: Unit => unit
}
let factoryAddressOrFail = factoryAddressOption.valueOrErrorMessage(wrapErr("invalid factory address"))

let lpAssetIdOption = match factoryAddressOption {
  case a: Address => match a.getString(keyLpAssetId()) {
    case s: String => s.fromBase58String()
    case _: Unit => unit
  }
  case _: Unit => unit
}
let lpAssetIdOrFail = lpAssetIdOption.valueOrErrorMessage(wrapErr("invalid lpAssetId"))

let treasuryAddressOption = match factoryAddressOption {
  case a: Address => match a.getString(keyTreasuryAddress()) {
    case s: String => s.addressFromString()
    case _: Unit => unit
  }
  case _: Unit => unit
}
let treasuryAddressOrFail = treasuryAddressOption.valueOrErrorMessage(wrapErr("invalid treasury address"))

func onlyAddress(i: Invocation, address: Address) = {
  i.caller == address || throwErr("permission denied")
}

func onlyFactory(i: Invocation) = {
  onlyAddress(i, factoryAddressOrFail)
}

func rewardForOption(rewards: List[(Address, Int)], target: Address) = {
  let s = rewards.size()
  let (a0, r0) = rewards[0]
  let (a1, r1) = rewards[1]
  let (a2, r2) = rewards[2]
  if (s > 0 && a0 == target) then r0 
  else if (s > 1 && a1 == target) then r1
  else if (s > 2 && a2 == target) then r2
  else unit
}

# TODO: reissue lp tokens?
@Callable(i)
func claimLP(userAddressBytes: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let available = factoryAddressOrFail.getInteger(keyAvailable(userAddress)).valueOrElse(0)
  let claimed = factoryAddressOrFail.getInteger(keyClaimed(userAddress)).valueOrElse(0)
  let factoryActions = if (available > 0) then [
    factoryAddressOrFail.invoke("transferAsset", [
      userAddressBytes, available, lpAssetIdOrFail
    ], []),
    factoryAddressOrFail.invoke("integerEntry", [
      keyAvailable(userAddress),
      0
    ], []),
    factoryAddressOrFail.invoke("stringEntry", [
      keyClaimed(userAddress),
      claimed + available
    ], [])
  ] else throwErr("nothing to claim")

  (nil, factoryActions)
}

# payment in waves to fulfill all withdrawal requests
# TODO: do not finalize if there are unprocessed blocks
@Callable(i)
func finalize(
  newTreasuryVolumeInWaves: Int,
  xtnPrice: Int,
  pwrManagersBonus: Int, # 0..1×10⁸
  treasuryVolumeDiffAllocationCoef: Int # -1..1×10⁸
) = {
  strict checks = [
    i.originCaller == factoryAddressOrFail || throwErr("permission denied"),
    newTreasuryVolumeInWaves >= 0 || throwErr("invalid new treasury volume"),
    xtnPrice >= 0 || throwErr("invalid XTN price"),
    pwrManagersBonus >= 0 && pwrManagersBonus <= SCALE8 || throwErr("invalid PWR managers bonus"),
    treasuryVolumeDiffAllocationCoef >= -SCALE8 && treasuryVolumeDiffAllocationCoef <= SCALE8
      || throwErr("invalid treasury volume diff allocation coefficient")
  ]
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage(wrapErr("invalid period"))
  let newPeriod = currentPeriodOrFail + 1
  # TODO: calculate new price
  let newPrice = SCALE8
  
  # TODO: burn total withdrawal amount
  let lpAssetAmountToBurn = 0

  let factoryActions = [
    # update period
    factoryAddressOrFail.invoke("integerEntry", [keyCurrentPeriod(), newPeriod], []),
    # update price
    factoryAddressOrFail.invoke("integerEntry", [keyPriceForPeriod(newPeriod), newPrice], []),
    factoryAddressOrFail.invoke("burn", [lpAssetAmountToBurn], [])
    # factoryAddressOrFail.invoke("transferAsset", [
    #   userAddressBytes, lpAssetAmount, lpAssetIdOrFail
    # ], []),
    # factoryAddressOrFail.invoke("transferWaves", [
    #   treasuryAddressOrFail.bytes, paymentAmount
    # ], [AttachedPayment(unit, paymentAmount)])
  ]

  (nil, factoryActions)
}

# payment in waves
@Callable(i)
func invest(userAddressBytes: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage(wrapErr("invalid period"))
  let currentPriceOrFail =
    factoryAddressOrFail.getInteger(keyPriceForPeriod(currentPeriodOrFail)).valueOrErrorMessage(wrapErr("invalid price"))
  let payment = if (i.payments.size() == 1) then i.payments[0] else throwErr("invalid payments")
  let paymentAmount = if (payment.assetId == unit && payment.amount > 0) then {
    payment.amount
  } else throwErr("invalid payment amount")
  let lpAssetAmount = if (currentPriceOrFail > 0) then fraction(paymentAmount, SCALE8, currentPriceOrFail) else 0
  
  let factoryActions = [
    # TODO: increase invested amount
    factoryAddressOrFail.invoke("integerEntry", ["invested__WAVES", 0], []),
    factoryAddressOrFail.invoke("reissue", [lpAssetAmount], []),
    factoryAddressOrFail.invoke("transferAsset", [
      userAddressBytes, lpAssetAmount, lpAssetIdOrFail
    ], []),
    factoryAddressOrFail.invoke("transferWaves", [
      treasuryAddressOrFail.bytes, paymentAmount
    ], [AttachedPayment(unit, paymentAmount)])
  ]

  (nil, factoryActions)
}

@Callable(i)
func withdraw(userAddressBytes: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage(wrapErr("invalid period"))
  let payment = if (i.payments.size() == 1) then i.payments[0] else throwErr(wrapErr("invalid payments"))
  let paymentAssetId = if (payment.assetId == lpAssetIdOrFail) then lpAssetIdOrFail else throwErr("invalid payment asset")
  let paymentAmount = if (payment.amount > 0) then payment.amount else throwErr("invalid payment amount")

  # TODO: increase total withdrawal amount
  strict factoryActions = [
    factoryAddressOrFail.invoke("stringEntry", [
      keyWithdrawalRequest(userAddress, i.transactionId),
      valueWithdrawalRequest(PENDING, paymentAmount, currentPeriodOrFail + 1, unit)
    ], [])
  ]

  ([
    ScriptTransfer(factoryAddressOrFail, paymentAmount, paymentAssetId)
  ], factoryActions)
}

@Callable(i)
func cancelWithdraw(userAddressBytes: ByteVector, txId: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let withdrawalRequestOption = factoryAddressOrFail
    .getString(keyWithdrawalRequest(userAddress, txId))
    .valueOrErrorMessage(wrapErr("invalid withdrawal request"))
  let (status, lpAssetAmount, targetPeriod, claimTxId) = parseWithdrawalRequestValueOrFail(withdrawalRequestOption)
  if (status == PENDING) then {
    strict factoryActions = [
      factoryAddressOrFail.invoke("deleteEntry", [
        keyWithdrawalRequest(userAddress, txId)
      ], []),
      factoryAddressOrFail.invoke("transferAsset", [
        userAddressBytes, lpAssetAmount, lpAssetIdOrFail
      ], [])
    ]
    (nil, factoryActions)
  } else {
    throwErr("invalid withdrawal request status")
  }
}

@Callable(i)
func claimWaves(userAddressBytes: ByteVector, txId: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage(wrapErr("invalid period"))
  let withdrawalRequestOption = factoryAddressOrFail
    .getString(keyWithdrawalRequest(userAddress, txId))
    .valueOrErrorMessage(wrapErr("invalid withdrawal request"))
  let (status, lpAssetAmount, targetPeriod, claimTxId) = parseWithdrawalRequestValueOrFail(withdrawalRequestOption)
  if (status == FINISHED) then {
    throwErr("invalid withdrawal request status")
  } else if (currentPeriodOrFail < targetPeriod) then {
    throwErr("invalid withdrawal request period")
  } else {
    let currentPriceOrFail =
      factoryAddressOrFail.getInteger(keyPriceForPeriod(currentPeriodOrFail)).valueOrErrorMessage(wrapErr("invalid price"))
    let amount = if (currentPriceOrFail > 0) then fraction(lpAssetAmount, currentPriceOrFail, SCALE8) else 0
    let factoryActions = [
      factoryAddressOrFail.invoke("stringEntry", [
        keyWithdrawalRequest(userAddress, txId),
        valueWithdrawalRequest(FINISHED, lpAssetAmount, targetPeriod, i.transactionId)
      ], []),
      factoryAddressOrFail.invoke("burn", [lpAssetAmount], []),
      factoryAddressOrFail.invoke("transferWaves", [userAddressBytes, amount], [])
    ]
    (nil, factoryActions)
  }
}

@Callable(i)
func processBlocks(userAddressBytes: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod())
    .valueOrErrorMessage(wrapErr("invalid period"))
  let periodLength =
    factoryAddressOrFail.getInteger(keyPeriodLength())
    .valueOrErrorMessage(wrapErr("invalid period length"))
  let currentStartHeight = factoryAddressOrFail
    .getInteger(keyStartHeight(currentPeriodOrFail))
    .valueOrErrorMessage(wrapErr("invalid start height"))
  let currentPriceOrFail =
    factoryAddressOrFail.getInteger(keyPriceForPeriod(currentPeriodOrFail))
    .valueOrErrorMessage(wrapErr("invalid price"))
  let nextBlockToProcess = factoryAddressOrFail
    .getInteger(keyNextBlockToProcess())
    .valueOrErrorMessage(wrapErr("invalid next block to process"))

  let periodEndHeight = currentStartHeight + periodLength - 1
  let blocksProcessingBatchSizeMax = 40

  # do not process blocks not in current period
  let blocksProcessingBatchSize = if (
    height >= nextBlockToProcess
    && (nextBlockToProcess >= currentStartHeight || currentPeriodOrFail == 0)
    && nextBlockToProcess <= periodEndHeight
  ) then {
    min([periodEndHeight - nextBlockToProcess + 1, blocksProcessingBatchSizeMax])
  } else {
    throwErr(wrapErr("invalid target block"))
  }

  let blockProcessingReward = factoryAddressOrFail
    .getInteger(keyBlockProcessingReward())
    .valueOrErrorMessage(wrapErr("invalid block processing reward"))
  let blockProcessingRewardByGenerator = blockProcessingReward / blocksProcessingBatchSize
  let blockProcessingRewardByGeneratorRemainder = blockProcessingReward - blockProcessingRewardByGenerator * blocksProcessingBatchSize
  
  func map(acc: Int, inc: Int) = {
    if (inc >= blocksProcessingBatchSize) then {
      acc
    } else {
      let targetBlockHeight = nextBlockToProcess + inc
      let targetBlockInfo = blockInfoByHeight(targetBlockHeight).valueOrErrorMessage(wrapErr("invalid block info"))
      let treasuryRewardOrFail = rewardForOption(targetBlockInfo.rewards, treasuryAddressOrFail)
        .valueOrErrorMessage(wrapErr("invalid treasury reward for height " + targetBlockHeight.toString()))
      let generator = targetBlockInfo.generator
      let available = factoryAddressOrFail.getInteger(keyAvailable(generator)).valueOrElse(0)
      let lpAssetAmount = if (currentPriceOrFail > 0)
        then fraction(treasuryRewardOrFail - blockProcessingRewardByGenerator, SCALE8, currentPriceOrFail)
        else 0

      let callerReward = if (inc == blocksProcessingBatchSize - 1) then {
        blockProcessingRewardByGenerator + blockProcessingRewardByGeneratorRemainder
      } else {
        blockProcessingRewardByGenerator
      }
      
      strict factoryActionsSingle = [
        factoryAddressOrFail.invoke("stringEntry", [
          keyBlockProcessed(targetBlockHeight),
          makeString([
            i.transactionId.toBase58String(),
            userAddressBytes.toBase58String(),
            treasuryRewardOrFail.toString(),
            callerReward.toString(),
            lpAssetAmount.toString()
          ], SEP)
        ], []),
        factoryAddressOrFail.invoke("integerEntry", [
          keyAvailable(generator),
          available + lpAssetAmount
        ], [])
      ]

      acc + callerReward
    }
  }

  let list = [
    00, 01, 02, 03, 04, 05, 06, 07, 08, 09,
    10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
    30, 31, 32, 33, 34, 35, 36, 37, 38, 39
  ]
  strict callerReward = FOLD<40>(list, 0, map)

  strict actions = [
    factoryAddressOrFail.invoke("transferWaves", [
      userAddressBytes, callerReward
    ], []),
    factoryAddressOrFail.invoke("integerEntry", [
      keyNextBlockToProcess(),
      nextBlockToProcess + blocksProcessingBatchSize
    ], [])
  ]

  (nil, unit)
}

@Verifier(tx)
func verify() = {
  sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
}
