{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let CONTRACT_NAME = "calculator.ride"
let SCALE8 = 100_000_000
let PENDING = "PENDING"
let FINISHED = "FINISHED"

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func keyFactoryAddress() = ["%s", "factory"].makeString(SEP)
func keyLpAssetId() = ["%s", "lpAssetId"].makeString(SEP)
func keyTreasuryAddress() = ["%s", "treasury"].makeString(SEP)
func keyAvailable(userAddress: Address) = ["%s%s", "available", userAddress.toString()].makeString(SEP)
func keyClaimed(userAddress: Address) = ["%s%s", "claimed", userAddress.toString()].makeString(SEP)
func keyCurrentPeriod() = ["%s", "currentPeriod"].makeString(SEP)
func keyPriceForPeriod(period: Int) = ["%s%d", "price", period.toString()].makeString(SEP)
func keyStartHeight(period: Int) = ["%s%d", "startHeight", period.toString()].makeString(SEP)
func keyPeriodLength() = "%s__periodLength"
func keyBlockProcessingReward() = "%s__blockProcessingReward"
func keyNextBlockToProcess() = "%s__nextBlockToProcess"
func keyWithdrawalRequest(userAddress: Address, txId: ByteVector) =
  ["%s%s%s", "withdrawal", userAddress.toString(), txId.toBase58String()].makeString(SEP)
func valueWithdrawalRequest(status: String, lpAssetAmount: Int, targetPeriod: Int, claimTxId: ByteVector|Unit) = {
  let claimTxIdStr = match claimTxId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => "SOON"
  }
  ["%s%d%d%s", status, lpAssetAmount.toString(), targetPeriod.toString(), claimTxIdStr].makeString(SEP)
}
func parseWithdrawalRequestValueOrFail(s: String) = {
  let parts = s.split(SEP)
  if (parts.size() == 5) then {
    let status = parts[1]
    let lpAssetAmount = parts[2].parseInt().valueOrErrorMessage(wrapErr("invalid lpAssetAmount"))
    let targetPeriod = parts[3].parseInt().valueOrErrorMessage(wrapErr("invalid targetPeriod"))
    let claimTxId = parts[4]
    (status, lpAssetAmount, targetPeriod, claimTxId)
  } else {
    throwErr("invalid withdrawal request value")
  }
}

let factoryAddressOption = match this.getString(keyFactoryAddress()) {
  case s: String => s.addressFromString()
  case _: Unit => unit
}
let factoryAddressOrFail = factoryAddressOption.valueOrErrorMessage(wrapErr("invalid factory address"))

let lpAssetIdOption = match factoryAddressOption {
  case a: Address => match a.getString(keyLpAssetId()) {
    case s: String => s.fromBase58String()
    case _: Unit => unit
  }
  case _: Unit => unit
}
let lpAssetIdOrFail = lpAssetIdOption.valueOrErrorMessage(wrapErr("invalid lpAssetId"))

let treasuryAddressOption = match factoryAddressOption {
  case a: Address => match a.getString(keyTreasuryAddress()) {
    case s: String => s.addressFromString()
    case _: Unit => unit
  }
  case _: Unit => unit
}
let treasuryAddressOrFail = treasuryAddressOption.valueOrErrorMessage(wrapErr("invalid treasury address"))

func onlyAddress(i: Invocation, address: Address) = {
  i.caller == address || throwErr("permission denied")
}

func onlyFactory(i: Invocation) = {
  onlyAddress(i, factoryAddressOrFail)
}

func rewardForOption(rewards: List[(Address, Int)], target: Address) = {
  let s = rewards.size()
  let (a0, r0) = rewards[0]
  let (a1, r1) = rewards[1]
  let (a2, r2) = rewards[2]
  if (s > 0 && a0 == target) then r0 
  else if (s > 1 && a1 == target) then r1
  else if (s > 2 && a2 == target) then r2
  else unit
}

@Callable(i)
func claimLP(userAddressBytes: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let available = factoryAddressOrFail.getInteger(keyAvailable(userAddress)).valueOrElse(0)
  let claimed = factoryAddressOrFail.getInteger(keyClaimed(userAddress)).valueOrElse(0)
  let factoryActions = if (available > 0) then [
    factoryAddressOrFail.invoke("transferAsset", [
      userAddressBytes, available, lpAssetIdOrFail
    ], []),
    factoryAddressOrFail.invoke("integerEntry", [
      keyAvailable(userAddress),
      0
    ], []),
    factoryAddressOrFail.invoke("stringEntry", [
      keyClaimed(userAddress),
      claimed + available
    ], [])
  ] else []

  (nil, factoryActions)
}

# payment in waves to fulfill all withdrawal requests
# TODO: do not finalize if there are unprocessed blocks
@Callable(i)
func finalize(
  newTreasuryVolumeInWaves: Int,
  xtnPrice: Int,
  pwrManagersBonus: Int, # 0..1×10⁸
  treasuryVolumeDiffAllocationCoef: Int # -1..1×10⁸
) = {
  strict checks = [
    i.originCaller == factoryAddressOrFail || throwErr("permission denied"),
    newTreasuryVolumeInWaves >= 0 || throwErr("invalid new treasury volume"),
    xtnPrice >= 0 || throwErr("invalid XTN price"),
    pwrManagersBonus >= 0 && pwrManagersBonus <= SCALE8 || throwErr("invalid PWR managers bonus"),
    treasuryVolumeDiffAllocationCoef >= -SCALE8 && treasuryVolumeDiffAllocationCoef <= SCALE8
      || throwErr("invalid treasury volume diff allocation coefficient")
  ]
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage(wrapErr("invalid period"))
  let newPeriod = currentPeriodOrFail + 1
  # TODO: calculate new price
  let newPrice = SCALE8
  
  # TODO: burn total withdrawal amount
  let lpAssetAmountToBurn = 0

  let factoryActions = [
    # update period
    factoryAddressOrFail.invoke("integerEntry", [keyCurrentPeriod(), newPeriod], []),
    # update price
    factoryAddressOrFail.invoke("integerEntry", [keyPriceForPeriod(newPeriod), newPrice], []),
    factoryAddressOrFail.invoke("burn", [lpAssetAmountToBurn], [])
    # factoryAddressOrFail.invoke("transferAsset", [
    #   userAddressBytes, lpAssetAmount, lpAssetIdOrFail
    # ], []),
    # factoryAddressOrFail.invoke("transferWaves", [
    #   treasuryAddressOrFail.bytes, paymentAmount
    # ], [AttachedPayment(unit, paymentAmount)])
  ]

  (nil, factoryActions)
}

# payment in waves
@Callable(i)
func invest(userAddressBytes: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage(wrapErr("invalid period"))
  let currentPriceOrFail =
    factoryAddressOrFail.getInteger(keyPriceForPeriod(currentPeriodOrFail)).valueOrErrorMessage(wrapErr("invalid price"))
  let payment = if (i.payments.size() == 1) then i.payments[0] else throwErr("invalid payments")
  let paymentAmount = if (payment.assetId == unit && payment.amount > 0) then {
    payment.amount
  } else throwErr("invalid payment amount")
  let lpAssetAmount = if (currentPriceOrFail > 0) then fraction(paymentAmount, SCALE8, currentPriceOrFail) else 0
  
  let factoryActions = [
    # TODO: increase invested amount
    factoryAddressOrFail.invoke("integerEntry", ["invested__WAVES", 0], []),
    factoryAddressOrFail.invoke("reissue", [lpAssetAmount], []),
    factoryAddressOrFail.invoke("transferAsset", [
      userAddressBytes, lpAssetAmount, lpAssetIdOrFail
    ], []),
    factoryAddressOrFail.invoke("transferWaves", [
      treasuryAddressOrFail.bytes, paymentAmount
    ], [AttachedPayment(unit, paymentAmount)])
  ]

  (nil, factoryActions)
}

@Callable(i)
func withdraw(userAddressBytes: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage(wrapErr("invalid period"))
  let payment = if (i.payments.size() == 1) then i.payments[0] else throwErr(wrapErr("invalid payments"))
  let paymentAssetId = if (payment.assetId == lpAssetIdOrFail) then lpAssetIdOrFail else throwErr("invalid payment asset")
  let paymentAmount = if (payment.amount > 0) then payment.amount else throwErr("invalid payment amount")

  # TODO: increase total withdrawal amount
  strict factoryActions = [
    factoryAddressOrFail.invoke("stringEntry", [
      keyWithdrawalRequest(userAddress, i.transactionId),
      valueWithdrawalRequest(PENDING, paymentAmount, currentPeriodOrFail + 1, unit)
    ], [])
  ]

  ([
    ScriptTransfer(factoryAddressOrFail, paymentAmount, paymentAssetId)
  ], factoryActions)
}

@Callable(i)
func cancelWithdraw(userAddressBytes: ByteVector, txId: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let withdrawalRequestOption = factoryAddressOrFail
    .getString(keyWithdrawalRequest(userAddress, txId))
    .valueOrErrorMessage(wrapErr("invalid withdrawal request"))
  let (status, lpAssetAmount, targetPeriod, claimTxId) = parseWithdrawalRequestValueOrFail(withdrawalRequestOption)
  if (status == PENDING) then {
    strict factoryActions = [
      factoryAddressOrFail.invoke("deleteEntry", [
        keyWithdrawalRequest(userAddress, txId)
      ], []),
      factoryAddressOrFail.invoke("transferAsset", [
        userAddressBytes, lpAssetAmount, lpAssetIdOrFail
      ], [])
    ]
    (nil, factoryActions)
  } else {
    throwErr("invalid withdrawal request status")
  }
}

@Callable(i)
func claimWaves(userAddressBytes: ByteVector, txId: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage(wrapErr("invalid period"))
  let withdrawalRequestOption = factoryAddressOrFail
    .getString(keyWithdrawalRequest(userAddress, txId))
    .valueOrErrorMessage(wrapErr("invalid withdrawal request"))
  let (status, lpAssetAmount, targetPeriod, claimTxId) = parseWithdrawalRequestValueOrFail(withdrawalRequestOption)
  if (status == FINISHED) then {
    throwErr("invalid withdrawal request status")
  } else if (currentPeriodOrFail < targetPeriod) then {
    throwErr("invalid withdrawal request period")
  } else {
    let currentPriceOrFail =
      factoryAddressOrFail.getInteger(keyPriceForPeriod(currentPeriodOrFail)).valueOrErrorMessage(wrapErr("invalid price"))
    let amount = if (currentPriceOrFail > 0) then fraction(lpAssetAmount, currentPriceOrFail, SCALE8) else 0
    let factoryActions = [
      factoryAddressOrFail.invoke("stringEntry", [
        keyWithdrawalRequest(userAddress, txId),
        valueWithdrawalRequest(FINISHED, lpAssetAmount, targetPeriod, i.transactionId)
      ], []),
      factoryAddressOrFail.invoke("burn", [lpAssetAmount], []),
      factoryAddressOrFail.invoke("transferWaves", [userAddressBytes, amount], [])
    ]
    (nil, factoryActions)
  }
}

@Callable(i)
func processBlocks(userAddressBytes: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage(wrapErr("invalid period"))
  let periodLength =
    factoryAddressOrFail.getInteger(keyPeriodLength()).valueOrErrorMessage(wrapErr("invalid period length"))
  let currentStartHeight = factoryAddressOrFail
    .getInteger(keyStartHeight(currentPeriodOrFail))
    .valueOrErrorMessage(wrapErr("invalid start height"))
  let currentPriceOrFail =
    factoryAddressOrFail.getInteger(keyPriceForPeriod(currentPeriodOrFail)).valueOrErrorMessage(wrapErr("invalid price"))
  let nextBlockToProcess = factoryAddressOrFail
    .getInteger(keyNextBlockToProcess())
    .valueOrErrorMessage(wrapErr("invalid next block to process"))
  
  # do not process blocks not in current period
  let targetBlockInfo = if (
    height >= nextBlockToProcess
    && (nextBlockToProcess >= currentStartHeight || currentPeriodOrFail == 0)
    && nextBlockToProcess < currentStartHeight + periodLength
  )
    then blockInfoByHeight(nextBlockToProcess).valueOrErrorMessage(wrapErr("invalid block info"))
    else throwErr(wrapErr("invalid target block"))
  let treasuryRewardOrFail = rewardForOption(targetBlockInfo.rewards, treasuryAddressOrFail)
    .valueOrErrorMessage(wrapErr("invalid treasury reward"))

  let blockProcessingRewardOrFail = factoryAddressOrFail
    .getInteger(keyBlockProcessingReward())
    .valueOrErrorMessage(wrapErr("invalid block processing reward"))
  let available = factoryAddressOrFail.getInteger(keyAvailable(userAddress)).valueOrElse(0)
  let lpAssetAmount = if (currentPriceOrFail > 0)
    then fraction(treasuryRewardOrFail - blockProcessingRewardOrFail, SCALE8, currentPriceOrFail)
    else 0
  let factoryActions = [
    factoryAddressOrFail.invoke("integerEntry", [
      keyNextBlockToProcess(),
      nextBlockToProcess + 1
    ], []),
    factoryAddressOrFail.invoke("integerEntry", [
      keyAvailable(userAddress),
      available
    ], []),
    factoryAddressOrFail.invoke("transferWaves", [
      userAddressBytes, blockProcessingRewardOrFail
    ], [])
  ]
  (nil, factoryActions)
}

@Verifier(tx)
func verify() = {
  sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
}
