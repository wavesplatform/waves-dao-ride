{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let contractFilename = "calculator.ride"

func wrapErr(s: String) = {
  contractFilename + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func keyFactoryAddress() = "%s__factory"
func keyLpAssetId() = "%s__lpAssetId"
func keyAvailable(userAddress: Address) = "%s%s__available__" + userAddress.toString()
func keyClaimed(userAddress: Address) = "%s%s__claimed__" + userAddress.toString()

let factoryAddressOption = match this.getString(keyFactoryAddress()) {
  case s: String => s.addressFromString()
  case _: Unit => unit
}
let factoryAddressOrFail = factoryAddressOption.valueOrErrorMessage(wrapErr("invalid factory address"))

let lpAssetIdOption = match factoryAddressOption {
  case a: Address => match a.getString(keyLpAssetId()) {
    case s: String => s.fromBase58String()
    case _: Unit => unit
  }
  case _: Unit => unit
}
let lpAssetIdOrFail = lpAssetIdOption.valueOrErrorMessage(wrapErr("invalid lpAssetId"))

func onlyAddress(i: Invocation, address: Address) = {
  i.caller == address || throwErr("permission denied")
}

func onlyFactory(i: Invocation) = {
  onlyAddress(i, factoryAddressOrFail)
}

func rewardForOption(rewards: List[(Address, Int)], target: Address) = {
  let s = rewards.size()
  let (a0, r0) = rewards[0]
  let (a1, r1) = rewards[1]
  let (a2, r2) = rewards[2]
  if (s > 0 && a0 == target) then r0 
  else if (s > 1 && a1 == target) then r1
  else if (s > 2 && a2 == target) then r2
  else unit
}

@Callable(i)
func claimLP(userAddressBytes: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let available = factoryAddressOrFail.getInteger(keyAvailable(userAddress)).valueOrElse(0)
  let claimed = factoryAddressOrFail.getInteger(keyClaimed(userAddress)).valueOrElse(0)
  let actions = if (available > 0) then [
    ScriptTransfer(userAddress, available, lpAssetIdOrFail),
    IntegerEntry(keyAvailable(userAddress), 0),
    IntegerEntry(keyClaimed(userAddress), claimed + available)
  ] else []

  (actions, available)
}

# payment in waves to fulfill all withdrawal requests
@Callable(i)
func finalize(
  newTreasuryVolumeInWaves: Int,
  xtnPrice: Int,
  pwrManagersBonus: Int, # 0..1×10⁸
  treasuryVolumeDiffAllocationCoef: Int # -1..1×10⁸
) = {
  (nil, unit)
}

@Callable(i)
func claimWaves(userAddressBytes: ByteVector, epoch: Int) = {
  (nil, unit)
}

@Callable(i)
func invest(userAddressBytes: ByteVector) = {
  (nil, unit)
}

@Callable(i)
func withdraw(userAddressBytes: ByteVector) = {
  (nil, unit)
}

@Callable(i)
func cancelWithdraw(userAddressBytes: ByteVector, txId: ByteVector) = {
  (nil, unit)
}

@Verifier(tx)
func verify() = {
  false
}
