{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let CONTRACT_NAME = "calculator.ride"
let PRICE_SCALE = 100_000_000
let PENDING = "PENDING"
let FINISHED = "FINISHED"

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func keyFactoryAddress() = ["%s", "factory"].makeString(SEP)
func keyLpAssetId() = ["%s", "lpAssetId"].makeString(SEP)
func keyTreasuryAddress() = ["%s", "treasury"].makeString(SEP)
func keyAvailable(userAddress: Address) = ["%s%s", "available", userAddress.toString()].makeString(SEP)
func keyClaimed(userAddress: Address) = ["%s%s", "claimed", userAddress.toString()].makeString(SEP)
func keyCurrentPeriod() = ["%s", "currentPeriod"].makeString(SEP)
func keyPriceForPeriod(period: Int) = ["%s%d", "price", period.toString()].makeString(SEP)
func keyWithdrawalRequest(userAddress: Address, txId: ByteVector) =
  ["%s%s%s", "withdrawal", userAddress.toString(), txId.toBase58String()].makeString(SEP)
func valueWithdrawalRequest(status: String, lpAssetAmount: Int, targetPeriod: Int, claimTxId: ByteVector|Unit) = {
  let claimTxIdStr = match claimTxId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => "SOON"
  }
  ["%s%d%d%s", status, lpAssetAmount.toString(), targetPeriod.toString(), claimTxIdStr].makeString(SEP)
}
func parseWithdrawalRequestValueOrFail(s: String) = {
  let parts = s.split(SEP)
  if (parts.size() == 5) then {
    let status = parts[1]
    let lpAssetAmount = parts[2].parseInt().valueOrErrorMessage("invalid lpAssetAmount")
    let targetPeriod = parts[3].parseInt().valueOrErrorMessage("invalid targetPeriod")
    let claimTxId = parts[4]
    (status, lpAssetAmount, targetPeriod, claimTxId)
  } else {
    throwErr("invalid withdrawal request value")
  }
}

let factoryAddressOption = match this.getString(keyFactoryAddress()) {
  case s: String => s.addressFromString()
  case _: Unit => unit
}
let factoryAddressOrFail = factoryAddressOption.valueOrErrorMessage(wrapErr("invalid factory address"))

let lpAssetIdOption = match factoryAddressOption {
  case a: Address => match a.getString(keyLpAssetId()) {
    case s: String => s.fromBase58String()
    case _: Unit => unit
  }
  case _: Unit => unit
}
let lpAssetIdOrFail = lpAssetIdOption.valueOrErrorMessage(wrapErr("invalid lpAssetId"))

let treasuryAddressOption = match factoryAddressOption {
  case a: Address => match a.getString(keyTreasuryAddress()) {
    case s: String => s.addressFromString()
    case _: Unit => unit
  }
  case _: Unit => unit
}
let treasuryAddressOrFail = treasuryAddressOption.valueOrErrorMessage(wrapErr("invalid treasury address"))

func onlyAddress(i: Invocation, address: Address) = {
  i.caller == address || throwErr("permission denied")
}

func onlyFactory(i: Invocation) = {
  onlyAddress(i, factoryAddressOrFail)
}

func rewardForOption(rewards: List[(Address, Int)], target: Address) = {
  let s = rewards.size()
  let (a0, r0) = rewards[0]
  let (a1, r1) = rewards[1]
  let (a2, r2) = rewards[2]
  if (s > 0 && a0 == target) then r0 
  else if (s > 1 && a1 == target) then r1
  else if (s > 2 && a2 == target) then r2
  else unit
}

@Callable(i)
func claimLP(userAddressBytes: ByteVector) = {
  strict checkCaller = i.onlyFactory()
  let userAddress = Address(userAddressBytes)
  let available = factoryAddressOrFail.getInteger(keyAvailable(userAddress)).valueOrElse(0)
  let claimed = factoryAddressOrFail.getInteger(keyClaimed(userAddress)).valueOrElse(0)
  let factoryActions = if (available > 0) then [
    factoryAddressOrFail.invoke("transferAsset", [
      userAddressBytes, available, lpAssetIdOrFail
    ], []),
    factoryAddressOrFail.invoke("integerEntry", [
      keyAvailable(userAddress),
      0
    ], []),
    factoryAddressOrFail.invoke("stringEntry", [
      keyClaimed(userAddress),
      claimed + available
    ], [])
  ] else []

  (nil, factoryActions)
}

# payment in waves to fulfill all withdrawal requests
@Callable(i)
func finalize(
  newTreasuryVolumeInWaves: Int,
  xtnPrice: Int,
  pwrManagersBonus: Int, # 0..1×10⁸
  treasuryVolumeDiffAllocationCoef: Int # -1..1×10⁸
) = {
  (nil, unit)
}

# payment in waves
@Callable(i)
func invest(userAddressBytes: ByteVector) = {
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage("invalid period")
  let currentPriceOrFail =
    factoryAddressOrFail.getInteger(keyPriceForPeriod(currentPeriodOrFail)).valueOrErrorMessage("invalid price")
  let payment = if (i.payments.size() == 1) then i.payments[0] else throwErr("invalid payments")
  let paymentAmount = if (payment.assetId == unit && payment.amount > 0) then {
    payment.amount
  } else throwErr("invalid payment amount")
  let lpAssetAmount = if (currentPriceOrFail > 0) then fraction(paymentAmount, PRICE_SCALE, currentPriceOrFail) else 0
  
  let factoryActions = [
    # TODO: increase invested amount
    factoryAddressOrFail.invoke("integerEntry", ["invested__WAVES", 0], []),
    factoryAddressOrFail.invoke("reissue", [lpAssetAmount], []),
    factoryAddressOrFail.invoke("transferAsset", [
      userAddressBytes, lpAssetAmount, lpAssetIdOrFail
    ], []),
    factoryAddressOrFail.invoke("transferWaves", [
      treasuryAddressOrFail.bytes, paymentAmount
    ], [AttachedPayment(unit, paymentAmount)])
  ]

  (nil, factoryActions)
}

@Callable(i)
func withdraw(userAddressBytes: ByteVector) = {
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage("invalid period")
  let payment = if (i.payments.size() == 1) then i.payments[0] else throwErr("invalid payments")
  let paymentAssetId = if (payment.assetId == lpAssetIdOrFail) then lpAssetIdOrFail else throwErr("invalid payment asset")
  let paymentAmount = if (payment.amount > 0) then payment.amount else throwErr("invalid payment amount")

  # TODO: increase total withdrawal amount
  strict factoryActions = [
    factoryAddressOrFail.invoke("stringEntry", [
      keyWithdrawalRequest(userAddress, i.transactionId),
      valueWithdrawalRequest(PENDING, paymentAmount, currentPeriodOrFail + 1, unit)
    ], [])
  ]

  ([
    ScriptTransfer(factoryAddressOrFail, paymentAmount, paymentAssetId)
  ], factoryActions)
}

@Callable(i)
func cancelWithdraw(userAddressBytes: ByteVector, txId: ByteVector) = {
  let userAddress = Address(userAddressBytes)
  let withdrawalRequestOption = factoryAddressOrFail
    .getString(keyWithdrawalRequest(userAddress, txId))
    .valueOrErrorMessage("invalid withdrawal request")
  let (status, lpAssetAmount, targetPeriod, claimTxId) = parseWithdrawalRequestValueOrFail(withdrawalRequestOption)
  if (status == PENDING) then {
    strict factoryActions = [
      factoryAddressOrFail.invoke("deleteEntry", [
        keyWithdrawalRequest(userAddress, txId)
      ], []),
      factoryAddressOrFail.invoke("transferAsset", [
        userAddressBytes, lpAssetAmount, lpAssetIdOrFail
      ], [])
    ]
    (nil, factoryActions)
  } else {
    throwErr("invalid withdrawal request status")
  }
}

@Callable(i)
func claimWaves(userAddressBytes: ByteVector, txId: ByteVector) = {
  let userAddress = Address(userAddressBytes)
  let currentPeriodOrFail =
    factoryAddressOrFail.getInteger(keyCurrentPeriod()).valueOrErrorMessage("invalid period")
  let withdrawalRequestOption = factoryAddressOrFail
    .getString(keyWithdrawalRequest(userAddress, txId))
    .valueOrErrorMessage("invalid withdrawal request")
  let (status, lpAssetAmount, targetPeriod, claimTxId) = parseWithdrawalRequestValueOrFail(withdrawalRequestOption)
  if (status == FINISHED) then {
    throwErr("invalid withdrawal request status")
  } else if (currentPeriodOrFail < targetPeriod) then {
    throwErr("invalid withdrawal request period")
  } else {
    let currentPriceOrFail =
      factoryAddressOrFail.getInteger(keyPriceForPeriod(currentPeriodOrFail)).valueOrErrorMessage("invalid price")
    let amount = if (currentPriceOrFail > 0) then fraction(lpAssetAmount, currentPriceOrFail, PRICE_SCALE) else 0
    let factoryActions = [
      factoryAddressOrFail.invoke("stringEntry", [
        keyWithdrawalRequest(userAddress, txId),
        valueWithdrawalRequest(FINISHED, lpAssetAmount, targetPeriod, i.transactionId)
      ], []),
      factoryAddressOrFail.invoke("burn", [lpAssetAmount], []),
      factoryAddressOrFail.invoke("transferWaves", [userAddressBytes, amount], [])
    ]
    (nil, factoryActions)
  }
}

@Verifier(tx)
func verify() = {
  false
}
