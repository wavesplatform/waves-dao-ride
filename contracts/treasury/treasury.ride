{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let contractFilename = "treasury.ride"
let ADMIN_LIST_SIZE = 3
let QUORUM = 2
let ADDRESS_BYTES_LENGTH = 26
let TXID_BYTES_LENGTH = 32

func wrapErr(s: String) = {
  contractFilename + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func keyAllowedTxIdVotePrefix(txId: String) = makeString(["%s%s%s", "allowTxId", txId], SEP)

# Make Admin vote key 
func keyFullAdminVote(prefix: String, adminAddress: String) = makeString([prefix, adminAddress], SEP)

# Admin List key
func keyAdminAddressList() = makeString(["%s", "adminAddressList"], SEP)

# Allowed TXID key
func keyAllowedTxId() = makeString(["%s", "txId"], SEP)

func keyConfigAddress() = "%s__config"
func keyVotingResultAddress() = "contract_voting_result"
func keyProposalAllowBroadcast(address: Address, txId: ByteVector) = {
  "proposal_allow_broadcast_" + address.toString() + "_" + txId.toBase58String()
}
let configAddress = this.getString(keyConfigAddress()).valueOrErrorMessage(wrapErr("no config"))
  .addressFromString().valueOrErrorMessage(wrapErr("invalid config address"))
let votingResultContract = configAddress.getString(keyVotingResultAddress()).valueOrErrorMessage(wrapErr("no voting result address"))
  .addressFromString().valueOrErrorMessage(wrapErr("invalid voting result address"))

func getAdminVote(prefix: String, admin: String) = {
  let voteKey = keyFullAdminVote(prefix, admin)
  getInteger(voteKey).valueOrElse(0)
}

func getAdminsList() = {
  match (this.getString(keyAdminAddressList())) {
    case s:String => s.split(SEP)
    case _ => []
  }
}

func isInAdminList(address: String) = {
  getAdminsList().containsElement(address)
}

# Generate List of keys with same prefix for all admins
func genVotesKeysHelper(a: (List[String], String), adminAddress: String) = {
  let (result, prefix) = a
  (result :+ keyFullAdminVote(prefix, adminAddress), prefix)
}
func genVotesKeys(keyPrefix: String) = {
  let adminList = keyAdminAddressList()
  let (result, prefix) = FOLD<3>(getAdminsList(), ([], keyPrefix), genVotesKeysHelper)
  result
}

# Count all votes for Prefix
func countVotesHelper(result: Int, voteKey: String) = {
  result + getInteger(voteKey).valueOrElse(0)
}
func countVotes(prefix: String) = {
  let votes = genVotesKeys(prefix)
  FOLD<3>(votes, 0, countVotesHelper)
}

# Generate DeleteEntry for all votes with Prefix
func clearVotesHelper(result: List[DeleteEntry], key: String) = {
  result :+ DeleteEntry(key) 
}
func getClearVoteEntries(prefix: String) = {
  let votes = genVotesKeys(prefix)
  FOLD<3>(votes, [], clearVotesHelper)
}

func voteINTERNAL(
  callerAddressString: String, 
  keyPrefix: String, 
  minVotes: Int, 
  voteResult: List[StringEntry|IntegerEntry|DeleteEntry]
) = {
  let voteKey = keyFullAdminVote(keyPrefix, callerAddressString)
  let adminCurrentVote = getAdminVote(keyPrefix, callerAddressString)

  strict err = if (!isInAdminList(callerAddressString)) then {
    throwErr("Address: " + callerAddressString + " not in Admin list")
  } else if (adminCurrentVote == 1) then {
    throwErr(voteKey + " you already voted")
  } else { unit }

  let votes = countVotes(keyPrefix)
  if (votes + 1 >= minVotes) then {
    let clearVoteEntries = getClearVoteEntries(keyPrefix)
    clearVoteEntries ++ voteResult
  } else {
    [ IntegerEntry(voteKey, 1) ]
  }
}

# Vote for txId that is allowed in Verifier (quorum: 2 votes)
@Callable(i)
func voteForTxId(txId: String) = {
  let callerAddressString = toBase58String(i.caller.bytes)
  let keyPrefix = keyAllowedTxIdVotePrefix(txId)
  let result = [ StringEntry(keyAllowedTxId(), txId) ]
  
  strict err = if (txId.fromBase58String().size() != TXID_BYTES_LENGTH) then {
    throwErr(txId + " is not valid txId")
  } else {
    unit 
  }

  voteINTERNAL(callerAddressString, keyPrefix, QUORUM, result)
}

@Verifier(tx)
func verify() = {
  let allowedTxId = getString(keyAllowedTxId())
    .valueOrErrorMessage(wrapErr("tx is not allowed"))
    .fromBase58String()
  let currentAdminList = getAdminsList()
  let proposalAllowBroadcast = votingResultContract.getBoolean(keyProposalAllowBroadcast(this, tx.id)).valueOrElse(false)
  if (currentAdminList.size() == ADMIN_LIST_SIZE) then {
    tx.id == allowedTxId || proposalAllowBroadcast
  } else {
    sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
  }
}
